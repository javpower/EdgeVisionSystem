<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¨æ¨¡æ¿åˆ›å»º - æœ€ç»ˆä¿®å¤ç‰ˆ</title>
    <style>
        /* ============ åŸºç¡€æ ·å¼ ============ */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a2e; color: #eee; overflow: hidden; width: 100vw; height: 100vh; }
        .container { display: flex; width: 100vw; height: 100vh; }

        /* ============ å·¦ä¾§ä¾§è¾¹æ  ============ */
        .sidebar { width: 300px; min-width: 300px; background: #16213e; border-right: 1px solid #0f3460; display: flex; flex-direction: column; overflow-y: auto; z-index: 100; }
        .sidebar-header { padding: 20px; background: #0f3460; }
        .sidebar-header h1 { font-size: 18px; color: #4cc9f0; }
        .sidebar-section { padding: 15px; border-bottom: 1px solid #1a1a2e; }
        .sidebar-section h3 { font-size: 13px; color: #4cc9f0; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; }

        /* è¡¨å•ç»„ä»¶ */
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; font-size: 12px; color: #888; margin-bottom: 5px; }
        .form-group input { width: 100%; padding: 8px 10px; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 4px; color: #eee; font-size: 13px; }
        .form-group input:focus { outline: none; border-color: #4cc9f0; }

        .btn { width: 100%; padding: 10px 14px; background: #4cc9f0; border: none; border-radius: 4px; color: #1a1a2e; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; margin-bottom: 8px; }
        .btn:hover:not(:disabled) { background: #3db5d8; }
        .btn:disabled { background: #444; color: #888; cursor: not-allowed; }
        .btn-secondary { background: #0f3460; color: #4cc9f0; }
        .btn-secondary:hover:not(:disabled) { background: #1a1a2e; }
        .btn-success { background: #00d9a0; color: #1a1a2e; }
        .btn.active { background: #e94560; color: #fff; }

        /* æ ‡æ³¨åˆ—è¡¨ */
        .annotation-list { max-height: 200px; overflow-y: auto; }
        .annotation-item { background: #1a1a2e; padding: 10px; margin-bottom: 8px; border-radius: 4px; border: 2px solid transparent; cursor: pointer; transition: 0.2s; }
        .annotation-item:hover { border-color: #4cc9f0; }
        .annotation-item.active { border-color: #4cc9f0; background: #0f3460; }
        .annotation-item-header { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 13px; font-weight: bold; }
        .annotation-item-delete { background: none; border: none; color: #e94560; cursor: pointer; font-size: 16px; width: 20px; text-align: center;}
        .annotation-item-info { font-size: 10px; color: #888; }

        /* ============ å³ä¾§ç”»å¸ƒåŒºåŸŸ ============ */
        .canvas-area { flex: 1; display: flex; flex-direction: column; background: #0d0d1a; position: relative; overflow: hidden; }

        .canvas-toolbar { padding: 10px 15px; background: #16213e; border-bottom: 1px solid #0f3460; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .canvas-toolbar-btn { padding: 6px 10px; background: #1a1a2e; border: 1px solid #0f3460; color: #eee; cursor: pointer; border-radius: 4px; font-size: 11px; }
        .canvas-toolbar-btn.active { background: #4cc9f0; color: #1a1a2e; border-color: #4cc9f0; }

        /* æ ¸å¿ƒå¸ƒå±€ä¿®å¤ï¼šCanvas å§‹ç»ˆé“ºæ»¡ */
        .canvas-container { flex: 1; position: relative; overflow: hidden; background: #0d0d1a; }
        .canvas-wrapper { position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; cursor: crosshair; }
        canvas { display: block; width: 100%; height: 100%; outline: none; }

        /* ============ è¾…åŠ© UI ============ */
        .status-bar { padding: 8px 15px; background: #16213e; border-top: 1px solid #0f3460; display: flex; justify-content: space-between; font-size: 10px; color: #888; }
        .mode-indicator { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); padding: 8px 20px; background: rgba(0,0,0,0.8); border-radius: 20px; pointer-events: none; z-index: 50; font-weight: bold; font-size: 13px; }
        .mode-crop { color: #4cc9f0; }
        .mode-annotate { color: #00d9a0; }

        .edit-hint { position: absolute; bottom: 130px; right: 20px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 6px; font-size: 11px; pointer-events: none; z-index: 50; color: #ccc; }

        .thumbnail-container { position: absolute; bottom: 20px; right: 20px; width: 150px; height: 100px; background: rgba(0,0,0,0.6); border: 1px solid #0f3460; pointer-events: none; z-index: 50; overflow: hidden; }
        .thumbnail-viewport { position: absolute; border: 2px solid #4cc9f0; background: rgba(76,201,240,0.1); }

        .toast { position: fixed; top: 20px; right: 20px; padding: 12px 18px; border-radius: 6px; z-index: 9999; animation: slideIn 0.3s; font-size: 13px; }
        .toast-success { background: #00d9a0; color: #1a1a2e; }
        .toast-error { background: #e94560; color: #fff; }
        .toast-info { background: #4cc9f0; color: #1a1a2e; }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        .empty-state { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #888; font-size: 15px; text-align: center; }
        .empty-state-icon { font-size: 48px; margin-bottom: 20px; }
    </style>
</head>
<body>
<div class="container">
    <div class="sidebar">
        <div class="sidebar-header"><h1>æ‰‹åŠ¨æ¨¡æ¿åˆ›å»º</h1></div>

        <div class="sidebar-section">
            <h3>1. åŠ è½½å›¾ç‰‡</h3>
            <div class="form-group">
                <label>å·¥ä»¶ç±»å‹</label>
                <input type="text" id="partType" placeholder="ä¾‹å¦‚: CX756002">
            </div>
            <button class="btn" onclick="captureImage()">æ‘„åƒå¤´æˆªå›¾</button>
            <input type="file" id="fileInput" accept="image/*" style="display: none" onchange="uploadImage(event)">
            <button class="btn btn-secondary" onclick="document.getElementById('fileInput').click()">ä¸Šä¼ æœ¬åœ°å›¾ç‰‡</button>
        </div>

        <div class="sidebar-section">
            <h3>2. æ¡†é€‰å·¥ä»¶æ•´ä½“</h3>
            <button class="btn btn-secondary" id="cropAreaBtn" onclick="toggleCropAreaMode()" disabled>å¼€å§‹æ¡†é€‰</button>
            <div id="cropAreaInfo" style="font-size: 10px; color: #888; margin-top: 8px;"></div>
        </div>

        <div class="sidebar-section">
            <h3>3. æ ‡æ³¨ç»†èŠ‚</h3>
            <div class="form-group"><label>ç‰¹å¾åç§°</label><input type="text" id="featureName" value="hole"></div>
            <div class="form-group"><label>ç±»åˆ«ID</label><input type="number" id="classId" value="0"></div>
            <button class="btn btn-success" id="annotateBtn" onclick="toggleAnnotateMode()" disabled>å¼€å§‹æ ‡æ³¨</button>
        </div>

        <div class="sidebar-section">
            <h3>æ ‡æ³¨åˆ—è¡¨ (<span id="annotationCount">0</span>)</h3>
            <div class="annotation-list" id="annotationList">
                <div style="color: #888; text-align: center; padding: 20px; font-size: 11px;">æš‚æ— æ ‡æ³¨</div>
            </div>
        </div>

        <div class="sidebar-section">
            <h3>å®¹å·®è®¾ç½®</h3>
            <div class="form-group"><label>Xå®¹å·® (åƒç´ )</label><input type="number" id="toleranceX" value="5.0" step="0.5"></div>
            <div class="form-group"><label>Yå®¹å·® (åƒç´ )</label><input type="number" id="toleranceY" value="5.0" step="0.5"></div>
        </div>

        <div class="sidebar-section">
            <h3>4. ä¿å­˜</h3>
            <div class="form-group"><input type="text" id="description" placeholder="æ¨¡æ¿æè¿°ï¼ˆå¯é€‰ï¼‰"></div>
            <button class="btn" id="previewBtn" onclick="previewTemplate()" disabled>é¢„è§ˆ</button>
            <button class="btn btn-success" id="saveBtn" onclick="saveTemplate()" disabled>ä¿å­˜æ¨¡æ¿</button>
        </div>
    </div>

    <div class="canvas-area">
        <div class="canvas-toolbar">
            <button class="canvas-toolbar-btn" id="panTool" onclick="setTool('pan')">æŠ“æ‰‹ (Space)</button>
            <button class="canvas-toolbar-btn active" id="selectTool" onclick="setTool('select')">é€‰æ‹© (V)</button>
            <button class="canvas-toolbar-btn" onclick="zoomIn()">æ”¾å¤§ (+)</button>
            <button class="canvas-toolbar-btn" onclick="zoomOut()">ç¼©å° (-)</button>
            <button class="canvas-toolbar-btn" onclick="fitToWindow()">é€‚åº” (F)</button>
            <span id="zoomLevel" style="color:#888; font-size:11px; margin-left:auto;">100%</span>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <div class="empty-state" id="emptyState">
                <div class="empty-state-icon">ğŸ“·</div>
                <div>è¯·å…ˆåŠ è½½å›¾ç‰‡</div>
            </div>
            <div class="canvas-wrapper" id="canvasWrapper" style="display: none;">
                <canvas id="imageCanvas"></canvas>
            </div>
        </div>

        <div class="edit-hint" id="editHint" style="display: none;">
            <h4>ç¼–è¾‘æ¨¡å¼</h4>
            <p>â€¢ æ‹–æ‹½è°ƒæ•´ä½ç½®/å¤§å°</p>
            <p>â€¢ åŒå‡»ä¿®æ”¹åç§°/é¢œè‰²</p>
            <p>â€¢ Delete åˆ é™¤</p>
        </div>

        <div class="thumbnail-container" id="thumbnailContainer" style="display: none;">
            <canvas id="thumbnailCanvas"></canvas>
            <div class="thumbnail-viewport" id="thumbnailViewport"></div>
        </div>

        <div class="status-bar">
            <span id="statusText">å°±ç»ª</span>
            <span id="mousePos">X: 0, Y: 0</span>
            <span id="imageSize"></span>
        </div>
    </div>
</div>

<script>
        // ============ å…¨å±€å˜é‡ ============
        let image = null;
        let canvas, ctx;
        let thumbnailCanvas, thumbnailCtx;

        // è§†å›¾çŠ¶æ€ (Offset/Scale)
        let scale = 1;
        let offsetX = 0, offsetY = 0;

        // äº¤äº’çŠ¶æ€
        let currentTool = 'select';
        let currentMode = null;
        let isPanning = false;
        let panStartX = 0, panStartY = 0;

        // æ•°æ®çŠ¶æ€
        let templateId = '';
        let cropArea = null;
        let annotations = [];
        let selectedAnnotation = null;

        // ç¼–è¾‘/ç»˜åˆ¶çŠ¶æ€
        let isDrawing = false;
        let isEditing = false;
        let drawStartX = 0, drawStartY = 0;
        let currentRect = null;
        let editTarget = null;
        let editHandle = null;
        let originalRect = null;
        let editStartPos = {x:0, y:0};

        // ç¼“å­˜
        let cacheCanvas = null;

        // å¸¸é‡
        const HANDLE_SIZE = 12;
        const HIT_TOLERANCE = 15;

        // ============ åˆå§‹åŒ– ============
        window.onload = function() {
            canvas = document.getElementById('imageCanvas');
            ctx = canvas.getContext('2d');
            thumbnailCanvas = document.getElementById('thumbnailCanvas');
            thumbnailCtx = thumbnailCanvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', () => {
                resizeCanvas();
                render();
            });

            setupEventListeners();
        };

        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            if(container && canvas) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                if(image) render();
            }
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel, {passive: false});
            canvas.addEventListener('dblclick', handleDoubleClick);

            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        // ============ æ ¸å¿ƒï¼šåæ ‡è½¬æ¢ (Fix: åŒ…å« Offset) ============
        function screenToImage(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = screenX - rect.left;
            const canvasY = screenY - rect.top;

            return {
                x: (canvasX - offsetX) / scale,
                y: (canvasY - offsetY) / scale
            };
        }

        // ============ API äº¤äº’ ============
        function captureImage() {
            const partType = document.getElementById('partType').value.trim();
            if (!partType) { showToast('è¯·è¾“å…¥å·¥ä»¶ç±»å‹', 'error'); return; }

            updateStatus('æ­£åœ¨æˆªå›¾...');

            fetch('/api/manual-template/capture', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({partType: partType})
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    templateId = data.data.templateId;
                    loadImage(data.data.imageUrl);
                    showToast('æˆªå›¾æˆåŠŸ', 'success');
                    updateStatus('å°±ç»ª');
                } else {
                    showToast(data.message, 'error');
                    updateStatus('æˆªå›¾å¤±è´¥');
                }
            })
            .catch(err => {
                showToast('APIè°ƒç”¨å¤±è´¥', 'error');
                updateStatus('æˆªå›¾å¤±è´¥');
            });
        }

        function uploadImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const partType = document.getElementById('partType').value.trim();
            if (!partType) {
                showToast('è¯·è¾“å…¥å·¥ä»¶ç±»å‹', 'error');
                event.target.value = '';
                return;
            }

            updateStatus('æ­£åœ¨ä¸Šä¼ ...');

            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;

                fetch('/api/manual-template/upload', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        partType: partType,
                        imageData: imageData
                    })
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        templateId = data.data.templateId;
                        loadImage(data.data.imageUrl);
                        showToast('ä¸Šä¼ æˆåŠŸ', 'success');
                        updateStatus('å°±ç»ª');
                    } else {
                        showToast(data.message, 'error');
                        updateStatus('ä¸Šä¼ å¤±è´¥');
                    }
                })
                .catch(err => {
                    // Fallback for demo/offline
                    console.warn("API Fail, fallback to local");
                    loadImage(imageData);
                    showToast('APIå¤±è´¥ï¼Œå·²åŠ è½½æœ¬åœ°é¢„è§ˆ', 'info');
                    templateId = 'temp_' + Date.now();
                });
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function loadImage(url) {
            image = new Image();
            image.crossOrigin = "Anonymous";

            image.onload = function() {
                document.getElementById('emptyState').style.display = 'none';
                document.getElementById('canvasWrapper').style.display = 'block';
                document.getElementById('thumbnailContainer').style.display = 'block';

                resizeCanvas();

                // ç¦»å±ç¼“å­˜
                cacheCanvas = document.createElement('canvas');
                cacheCanvas.width = image.width;
                cacheCanvas.height = image.height;
                cacheCtx = cacheCanvas.getContext('2d');
                cacheCtx.drawImage(image, 0, 0);

                // ç¼©ç•¥å›¾
                thumbnailCanvas.width = 150;
                thumbnailCanvas.height = 100 * (image.height / image.width);
                thumbnailCtx.drawImage(image, 0, 0, thumbnailCanvas.width, thumbnailCanvas.height);

                fitToWindow();

                document.getElementById('imageSize').textContent = `å›¾ç‰‡: ${image.width} x ${image.height}`;
                document.getElementById('cropAreaBtn').disabled = false;
                document.getElementById('annotateBtn').disabled = false;
            };
            image.src = url;
        }

        // ============ é¢„è§ˆ & ä¿å­˜ (Fix: æ„é€  nested bbox & Preview Blank) ============
        function previewTemplate() {
             if (!image || annotations.length === 0) {
                 showToast('è¯·å…ˆæ·»åŠ æ ‡æ³¨', 'error');
                 return;
             }

             // æ„é€  bbox ç»“æ„
             const requestAnnotations = annotations.map(ann => ({
                 id: ann.id,
                 name: ann.name,
                 classId: ann.classId,
                 bbox: {
                     x: Math.round(ann.x),
                     y: Math.round(ann.y),
                     width: Math.round(ann.width),
                     height: Math.round(ann.height)
                 },
                 required: true
             }));

             const requestCropArea = cropArea ? {
                 x: Math.round(cropArea.x),
                 y: Math.round(cropArea.y),
                 width: Math.round(cropArea.width),
                 height: Math.round(cropArea.height)
             } : null;

             const req = {
                 templateId: templateId,
                 cropArea: requestCropArea,
                 annotations: requestAnnotations
             };

             updateStatus('æ­£åœ¨ç”Ÿæˆé¢„è§ˆ...');

             fetch('/api/manual-template/preview', {
                 method: 'POST',
                 headers: {'Content-Type': 'application/json'},
                 body: JSON.stringify(req)
             })
             .then(res => res.json())
             .then(data => {
                 if (data.success && data.previewUrl) {
                     // Fix: ä½¿ç”¨ document.write é¿å…æµè§ˆå™¨æ‹¦æˆªæˆ– Base64 æ— æ³•ç›´æ¥å¯¼èˆª
                     const win = window.open('', '_blank');
                     if(win) {
                         win.document.write(`
                             <html><head><title>Preview</title></head>
                             <body style="margin:0;background:#0d0d1a;display:flex;justify-content:center;align-items:center;height:100vh;">
                             <img src="${data.previewUrl}" style="max-width:95%;max-height:95%;border:2px solid #4cc9f0;">
                             </body></html>
                         `);
                         win.document.close();
                         showToast('é¢„è§ˆå·²ç”Ÿæˆ', 'success');
                         updateStatus('å°±ç»ª');
                     } else {
                         showToast('å¼¹çª—è¢«æ‹¦æˆª', 'error');
                     }
                 } else {
                     showToast(data.message || 'é¢„è§ˆURLä¸ºç©º', 'error');
                     updateStatus('é¢„è§ˆå¤±è´¥');
                 }
             })
             .catch(err => {
                 showToast('é¢„è§ˆè¯·æ±‚å¤±è´¥', 'error');
                 updateStatus('é¢„è§ˆå¤±è´¥');
             });
        }

        function saveTemplate() {
            if (!image || annotations.length === 0) {
                showToast('è¯·å…ˆæ·»åŠ æ ‡æ³¨', 'error');
                return;
            }

            updateStatus('æ­£åœ¨ä¿å­˜...');

            const globalTolX = parseFloat(document.getElementById('toleranceX').value) || 5.0;
            const globalTolY = parseFloat(document.getElementById('toleranceY').value) || 5.0;

            const requestAnnotations = annotations.map(ann => ({
                id: ann.id,
                name: ann.name,
                classId: ann.classId,
                // Fix: æ„é€  nested bbox
                bbox: {
                    x: Math.round(ann.x),
                    y: Math.round(ann.y),
                    width: Math.round(ann.width),
                    height: Math.round(ann.height)
                },
                toleranceX: globalTolX,
                toleranceY: globalTolY,
                required: true
            }));

            const requestCropArea = cropArea ? {
                 x: Math.round(cropArea.x),
                 y: Math.round(cropArea.y),
                 width: Math.round(cropArea.width),
                 height: Math.round(cropArea.height)
            } : null;

            const request = {
                templateId: templateId,
                description: document.getElementById('description').value.trim(),
                cropArea: requestCropArea,
                toleranceX: globalTolX,
                toleranceY: globalTolY,
                annotations: requestAnnotations
            };

            fetch('/api/manual-template/save', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(request)
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    showToast('ä¿å­˜æˆåŠŸ!', 'success');
                    updateStatus('å°±ç»ª');
                } else {
                    showToast(data.message, 'error');
                    updateStatus('ä¿å­˜å¤±è´¥');
                }
            })
            .catch(err => {
                showToast('ä¿å­˜è¯·æ±‚å¤±è´¥', 'error');
                updateStatus('ä¿å­˜å¤±è´¥');
                console.error(request);
            });
        }

        // ============ æ¸²æŸ“å¼•æ“ ============
        function render() {
            if (!image || !cacheCanvas) return;

            // æ¸…ç©ºå…¨å±
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // åº”ç”¨å˜æ¢ (æ‰€æœ‰ç»˜åˆ¶åŸºäºæ­¤)
            ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

            ctx.drawImage(cacheCanvas, 0, 0);

            // ç»˜åˆ¶ CropArea
            if (cropArea) {
                const isSelected = selectedAnnotation === 'cropArea';
                drawRect(cropArea, '#0066ff', isSelected, 'Workpiece Area');
            }

            // ç»˜åˆ¶å½“å‰æ­£åœ¨ç”»çš„æ¡†
            if (currentRect) {
                const color = currentMode === 'cropArea' ? '#0066ff' : '#00d9a0';
                ctx.strokeStyle = color;
                ctx.lineWidth = 2 / scale;
                ctx.setLineDash([5/scale, 5/scale]);
                ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                ctx.setLineDash([]);

                const s = 10 / scale;
                ctx.beginPath();
                ctx.strokeStyle = '#fff';
                ctx.moveTo(drawStartX - s, drawStartY); ctx.lineTo(drawStartX + s, drawStartY);
                ctx.moveTo(drawStartX, drawStartY - s); ctx.lineTo(drawStartX, drawStartY + s);
                ctx.stroke();
            }

            // ç»˜åˆ¶ Annotations
            annotations.forEach((ann, idx) => {
                const isSelected = selectedAnnotation === ann;
                const color = getClassColor(ann.classId);
                drawRect(ann, color, isSelected, `${idx+1}. ${ann.name}`);
            });

            // UI Updates
            document.getElementById('zoomLevel').innerText = Math.round(scale * 100) + '%';
            updateThumbnailViewport();
        }

        function drawRect(rect, color, isSelected, label) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = (isSelected ? 3 : 2) / scale;
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

            if (isSelected) {
                ctx.fillStyle = color + "33";
                ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                drawHandles(rect, color);
            }

            ctx.fillStyle = color;
            const fontSize = Math.max(12, 14 / scale);
            ctx.font = `bold ${fontSize}px Arial`;
            const textY = Math.max(rect.y - 5/scale, rect.y + fontSize/scale);
            ctx.fillText(label, rect.x, textY);

            ctx.restore();
        }

        function drawHandles(rect, color) {
            const handles = getHandleCoords(rect);
            const size = HANDLE_SIZE / scale;

            ctx.fillStyle = color;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1 / scale;

            for (let h in handles) {
                const p = handles[h];
                ctx.beginPath();
                ctx.rect(p.x - size/2, p.y - size/2, size, size);
                ctx.fill();
                ctx.stroke();
            }
        }

        // ============ ç¢°æ’æ£€æµ‹ (Fix: åŒå‡»/ç§»åŠ¨æ£€æµ‹é€»è¾‘) ============
        function getHandleCoords(rect) {
            return {
                nw: {x: rect.x, y: rect.y},
                ne: {x: rect.x + rect.width, y: rect.y},
                sw: {x: rect.x, y: rect.y + rect.height},
                se: {x: rect.x + rect.width, y: rect.y + rect.height},
            };
        }

        function hitTest(imgX, imgY, rect) {
            if (!rect) return null;
            const tol = HIT_TOLERANCE / scale;

            // 1. Handles
            const handles = getHandleCoords(rect);
            for (let h in handles) {
                const p = handles[h];
                if (Math.abs(imgX - p.x) < tol && Math.abs(imgY - p.y) < tol) return h;
            }
            // 2. Inside Body
            if (imgX >= rect.x && imgX <= rect.x + rect.width &&
                imgY >= rect.y && imgY <= rect.y + rect.height) return 'move';

            return null;
        }

        function getCursor(handle) {
            if(!handle) return 'default';
            if(handle === 'move') return 'move';
            return handle + '-resize';
        }

        // ============ äº¤äº’äº‹ä»¶ ============
        function handleMouseDown(e) {
            if (!image) return;
            const pos = screenToImage(e.clientX, e.clientY);

            // 1. Pan
            if (e.button === 1 || currentTool === 'pan' || e.spaceKey) {
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                canvas.style.cursor = 'grabbing';
                return;
            }

            // 2. Draw
            if (currentMode) {
                isDrawing = true;
                drawStartX = pos.x;
                drawStartY = pos.y;
                currentRect = { x: pos.x, y: pos.y, width: 0, height: 0 };
                return;
            }

            // 3. Select / Edit
            if (currentTool === 'select') {
                let hitTarget = null;
                let hitHandle = null;

                // Priority: Current Selection -> Crop -> Others (Top-down)
                if (selectedAnnotation) {
                    const target = selectedAnnotation === 'cropArea' ? cropArea : selectedAnnotation;
                    hitHandle = hitTest(pos.x, pos.y, target);
                    if (hitHandle) hitTarget = target;
                }

                if (!hitTarget) {
                    if (cropArea && hitTest(pos.x, pos.y, cropArea)) {
                        hitTarget = cropArea;
                        hitHandle = hitTest(pos.x, pos.y, cropArea);
                        selectedAnnotation = 'cropArea';
                    } else {
                        // Reverse loop for z-index behavior
                        for (let i = annotations.length - 1; i >= 0; i--) {
                            const ann = annotations[i];
                            if (hitTest(pos.x, pos.y, ann)) {
                                hitTarget = ann;
                                hitHandle = hitTest(pos.x, pos.y, ann);
                                selectedAnnotation = ann;
                                break;
                            }
                        }
                    }
                }

                if (hitTarget) {
                    isEditing = true;
                    editTarget = hitTarget;
                    editHandle = hitHandle;
                    editStartPos = pos;
                    originalRect = { ...hitTarget };
                    updateAnnotationList();
                } else {
                    selectedAnnotation = null;
                    updateAnnotationList();
                }
                render();
            }
        }

        function handleMouseMove(e) {
            if (!image) return;
            const pos = screenToImage(e.clientX, e.clientY);
            document.getElementById('mousePos').innerText = `X:${Math.round(pos.x)}, Y:${Math.round(pos.y)}`;

            if (isPanning) {
                const dx = e.clientX - panStartX;
                const dy = e.clientY - panStartY;
                offsetX += dx;
                offsetY += dy;
                panStartX = e.clientX;
                panStartY = e.clientY;
                render();
                return;
            }

            if (isEditing && editTarget) {
                const dx = pos.x - editStartPos.x;
                const dy = pos.y - editStartPos.y;

                if (editHandle === 'move') {
                    editTarget.x = originalRect.x + dx;
                    editTarget.y = originalRect.y + dy;
                } else {
                    // Resize logic (Simplified NW/SE)
                    if (editHandle.includes('e')) editTarget.width = Math.max(10, originalRect.width + dx);
                    if (editHandle.includes('s')) editTarget.height = Math.max(10, originalRect.height + dy);
                    if (editHandle.includes('w')) {
                        const w = Math.max(10, originalRect.width - dx);
                        editTarget.x = originalRect.x + originalRect.width - w;
                        editTarget.width = w;
                    }
                    if (editHandle.includes('n')) {
                        const h = Math.max(10, originalRect.height - dy);
                        editTarget.y = originalRect.y + originalRect.height - h;
                        editTarget.height = h;
                    }
                }
                updateAnnotationList();
                render();
                return;
            }

            if (isDrawing && currentRect) {
                currentRect.width = pos.x - drawStartX;
                currentRect.height = pos.y - drawStartY;
                render();
                return;
            }

            if (currentTool === 'select' && !currentMode) {
                let cursor = 'default';
                const targets = [...annotations];
                if(cropArea) targets.push(cropArea);

                for(let t of targets) {
                    const h = hitTest(pos.x, pos.y, t);
                    if(h) {
                        cursor = getCursor(h);
                        break;
                    }
                }
                canvas.style.cursor = cursor;
            }
        }

        function handleMouseUp(e) {
            isPanning = false;
            isEditing = false;
            canvas.style.cursor = currentTool === 'pan' ? 'grab' : 'default';

            if (isDrawing && currentRect) {
                let r = {
                    x: currentRect.width < 0 ? currentRect.x + currentRect.width : currentRect.x,
                    y: currentRect.height < 0 ? currentRect.y + currentRect.height : currentRect.y,
                    width: Math.abs(currentRect.width),
                    height: Math.abs(currentRect.height)
                };

                if (r.width > 5 && r.height > 5) {
                    if (currentMode === 'cropArea') {
                        cropArea = r;
                        showToast('å·¥ä»¶åŒºåŸŸå·²è®¾ç½®', 'success');
                        toggleCropAreaMode();
                        selectedAnnotation = 'cropArea';
                    } else if (currentMode === 'annotate') {
                        const name = document.getElementById('featureName').value;
                        const cls = parseInt(document.getElementById('classId').value);
                        const newAnn = {
                            id: Date.now(),
                            name: name,
                            classId: cls,
                            ...r
                        };
                        annotations.push(newAnn);
                        selectedAnnotation = newAnn;
                        showToast(`å·²æ·»åŠ  ${name}`, 'success');
                    }
                    updateAnnotationList();
                }
                currentRect = null;
                isDrawing = false;
                render();
            }
        }

        function handleWheel(e) {
            if (!image) return;
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Zoom logic around mouse point
            const imgX = (mouseX - offsetX) / scale;
            const imgY = (mouseY - offsetY) / scale;

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.05, Math.min(50, scale * delta));

            offsetX = mouseX - imgX * newScale;
            offsetY = mouseY - imgY * newScale;

            scale = newScale;
            render();
        }

        // Fix: Double Click logic
        function handleDoubleClick(e) {
            if (!image) return;
            const pos = screenToImage(e.clientX, e.clientY);

            // Loop backwards to hit top-most element first
            for (let i = annotations.length - 1; i >= 0; i--) {
                const ann = annotations[i];
                if (hitTest(pos.x, pos.y, ann)) {
                    // 1. Prompt Name
                    const newName = prompt('ä¿®æ”¹ç‰¹å¾åç§°:', ann.name);
                    if (newName === null) return; // Cancelled

                    // 2. Prompt Class ID
                    const newClassIdStr = prompt('ä¿®æ”¹ç±»åˆ« ID (0-7):', ann.classId);
                    if (newClassIdStr === null) return; // Cancelled

                    // 3. Apply
                    if(newName.trim()) ann.name = newName.trim();
                    const cid = parseInt(newClassIdStr);
                    if(!isNaN(cid)) ann.classId = cid;

                    // 4. Force Update
                    selectedAnnotation = ann;
                    updateAnnotationList();
                    render();
                    showToast('å·²ä¿®æ”¹', 'success');
                    return;
                }
            }
        }

        // ============ Helpers ============
        function fitToWindow() {
            if (!image) return;
            const container = document.getElementById('canvasContainer');
            const cw = container.clientWidth;
            const ch = container.clientHeight;

            const scaleW = (cw - 40) / image.width;
            const scaleH = (ch - 40) / image.height;
            scale = Math.min(scaleW, scaleH);

            offsetX = (cw - image.width * scale) / 2;
            offsetY = (ch - image.height * scale) / 2;
            render();
        }

        function toggleCropAreaMode() {
            if (currentMode === 'cropArea') {
                currentMode = null;
                document.getElementById('cropAreaBtn').classList.remove('active');
                document.getElementById('cropAreaBtn').innerText = 'å¼€å§‹æ¡†é€‰';
                removeIndicator();
            } else {
                currentMode = 'cropArea';
                selectedAnnotation = null;
                document.getElementById('cropAreaBtn').classList.add('active');
                document.getElementById('cropAreaBtn').innerText = 'å–æ¶ˆæ¡†é€‰';
                if(currentMode === 'annotate') toggleAnnotateMode();
                showIndicator('æ¡†é€‰å·¥ä»¶åŒºåŸŸ', 'crop');
            }
            render();
        }

        function toggleAnnotateMode() {
            if (currentMode === 'annotate') {
                currentMode = null;
                document.getElementById('annotateBtn').classList.remove('active');
                document.getElementById('annotateBtn').innerText = 'å¼€å§‹æ ‡æ³¨';
                removeIndicator();
            } else {
                currentMode = 'annotate';
                document.getElementById('annotateBtn').classList.add('active');
                document.getElementById('annotateBtn').innerText = 'å–æ¶ˆæ ‡æ³¨';
                if(currentMode === 'cropArea') toggleCropAreaMode();
                showIndicator('æ ‡æ³¨ç‰¹å¾ç»†èŠ‚', 'annotate');
            }
            render();
        }

        function setTool(tool) {
            currentTool = tool;
            document.getElementById('panTool').classList.toggle('active', tool === 'pan');
            document.getElementById('selectTool').classList.toggle('active', tool === 'select');
            canvas.style.cursor = tool === 'pan' ? 'grab' : 'default';
        }

        function updateAnnotationList() {
            const list = document.getElementById('annotationList');
            let html = '';

            if (cropArea) {
                const active = selectedAnnotation === 'cropArea' ? 'active' : '';
                html += `
                    <div class="annotation-item ${active}" onclick="selectItem('cropArea')">
                        <div class="annotation-item-header"><span>å·¥ä»¶æ•´ä½“åŒºåŸŸ</span></div>
                        <div class="annotation-item-info">X:${Math.round(cropArea.x)} Y:${Math.round(cropArea.y)} W:${Math.round(cropArea.width)} H:${Math.round(cropArea.height)}</div>
                    </div>`;
            }

            if (annotations.length === 0 && !cropArea) {
                html = '<div style="color: #888; text-align: center; padding: 20px; font-size: 11px;">æš‚æ— æ ‡æ³¨</div>';
            } else {
                annotations.forEach((ann, i) => {
                    const active = selectedAnnotation === ann ? 'active' : '';
                    html += `
                    <div class="annotation-item ${active}" onclick="selectItem(${ann.id})">
                        <div class="annotation-item-header">
                            <span>${i+1}. ${ann.name}</span>
                            <button class="annotation-item-delete" onclick="event.stopPropagation(); deleteItem(${ann.id})">Ã—</button>
                        </div>
                        <div class="annotation-item-info">ID:${ann.classId} | W:${Math.round(ann.width)} H:${Math.round(ann.height)}</div>
                    </div>`;
                });
            }

            list.innerHTML = html;
            const count = annotations.length + (cropArea ? 1 : 0);
            document.getElementById('annotationCount').innerText = count;
            document.getElementById('cropAreaInfo').innerText = cropArea ? 'å·²è®¾å®š' : '';

            const canSave = annotations.length > 0;
            document.getElementById('previewBtn').disabled = !canSave;
            document.getElementById('saveBtn').disabled = !canSave;

            document.getElementById('editHint').style.display = selectedAnnotation ? 'block' : 'none';
        }

        function selectItem(id) {
            if (id === 'cropArea') selectedAnnotation = 'cropArea';
            else selectedAnnotation = annotations.find(a => a.id === id);
            render();
            updateAnnotationList();
        }

        function deleteItem(id) {
            annotations = annotations.filter(a => a.id !== id);
            if (selectedAnnotation && selectedAnnotation.id === id) selectedAnnotation = null;
            render();
            updateAnnotationList();
        }

        function getClassColor(id) {
            const colors = ['#00ff00', '#00ffff', '#ff00ff', '#ffff00', '#ff8000', '#8000ff'];
            return colors[id % colors.length];
        }

        function handleKeyDown(e) {
            if (e.code === 'Space' && !e.repeat) { e.spaceKey = true; setTool('pan'); }
            if (e.code === 'Delete' && selectedAnnotation) {
                if (selectedAnnotation === 'cropArea') {
                    if(confirm('åˆ é™¤å·¥ä»¶æ•´ä½“æ¡†?')) { cropArea = null; selectedAnnotation = null; }
                } else {
                    deleteItem(selectedAnnotation.id);
                }
                updateAnnotationList();
                render();
            }
            if (e.code === 'KeyF') fitToWindow();
            if (e.code === 'KeyV') setTool('select');
        }

        function handleKeyUp(e) {
            if (e.code === 'Space') { e.spaceKey = false; setTool('select'); }
        }

        function zoomIn() { scale *= 1.2; render(); }
        function zoomOut() { scale /= 1.2; render(); }

        function showIndicator(text, mode) {
            removeIndicator();
            const el = document.createElement('div');
            el.className = `mode-indicator mode-${mode}`;
            el.innerText = text;
            el.id = 'activeIndicator';
            document.querySelector('.canvas-area').appendChild(el);
        }

        function removeIndicator() {
            const el = document.getElementById('activeIndicator');
            if(el) el.remove();
        }

        function showToast(msg, type) {
            const t = document.createElement('div');
            t.className = `toast toast-${type}`;
            t.innerText = msg;
            document.body.appendChild(t);
            setTimeout(() => t.remove(), 3000);
        }

        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        function updateThumbnailViewport() {
            if(!image) return;
            const viewW = canvas.width / scale;
            const viewH = canvas.height / scale;
            const viewX = -offsetX / scale;
            const viewY = -offsetY / scale;

            const thumbScale = thumbnailCanvas.width / image.width;
            const vp = document.getElementById('thumbnailViewport');

            vp.style.left = (viewX * thumbScale) + 'px';
            vp.style.top = (viewY * thumbScale) + 'px';
            vp.style.width = (viewW * thumbScale) + 'px';
            vp.style.height = (viewH * thumbScale) + 'px';
        }
    </script>
</body>
</html>